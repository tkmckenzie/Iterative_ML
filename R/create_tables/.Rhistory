system("g++ -v")
cat('Sys.setenv(BINPREF = "C:/Rtools/mingw_$(WIN)/bin/")',
file = file.path(Sys.getenv("HOME"), ".Rprofile"),
sep = "\n", append = TRUE)
72000 + 18000
14 * 5870
12 * 5870
20000 / 70440
5870 * 0.2839
5870 - 2150 - 200
5870 - 2150 - 250
5870 - 2150 - 250 - 1700
2 * 5870 - 2150 - 250 - 1700
2 * 5870 - 2150 - 250 - 1700 * 2
5940 * 5
29700 - 1500 * 5
1500 + 1000 + 3050 + 500 + 3000 + 1000
1700 * 6
3400 * 6
72000 - 110000
38000 / 6
38000 / 12
110000-90000
20000/6
1800*2*6
28000 / 6
source('~/git/Iterative_ML/R/stan_sf_data/gp_sf_fit_ml_calc.R', echo=TRUE)
load("stan_gp_fits/stan_gp_sf_unconditional.RData")
traceplot(stan.fit)
#Restricted values:
stan.extract = extract(stan.fit)
sigma.u.restricted = mean(stan.extract$sigma_u)
sigma.v.restricted = mean(stan.extract$sigma_v)
H.inv.diag.restricted = apply(stan.extract$H_inv_diag, 2, mean)
alpha.restricted = mean(stan.extract$alpha)
eta.restricted = apply(stan.extract$eta, 2, mean)
load("data.RData")
N = nrow(X)
k = ncol(X)
##############################
#Likelihood evaluation
log.lik.func = function(epsilon, sigma.u, sigma.v){
sigma.sq = sigma.u^2 + sigma.v^2
sigma = sqrt(sigma.sq)
lambda = sigma.u / sigma.v
return(length(epsilon) * (log(2) - log(sigma)) + dnorm(epsilon / sigma, log = TRUE) + pnorm(epsilon * lambda / sigma, log = TRUE, lower.tail = FALSE))
}
normal.kernel = function(x, alpha, H.inv){
return(alpha^2 * exp(-0.5 * t(x) %*% H.inv %*% x))
}
normal.cov = function(alpha, H.inv){
result = matrix(NA, nrow = N, ncol = N)
for (i in 1:(N - 1)){
result[i, i] = alpha^2
for (j in (i + 1):N){
temp.result = normal.kernel(X[i,] - X[j,], alpha, H.inv)
result[i, j] = temp.result
result[j, i] = temp.result
}
}
result[N, N] = alpha^2
return(result)
}
cov = normal.cov(alpha.restricted, diag(H.inv.diag.restricted))
L = t(chol(cov))
f = L %*% eta.restricted
epsilon = c(y - f)
log.lik = sum(sapply(epsilon, log.lik.func, sigma.u = sigma.u.restricted, sigma.v = sigma.v.restricted))
traceplot(stan.fit)
#Restricted values:
stan.extract = extract(stan.fit)
sigma.u.restricted = mean(stan.extract$sigma_u)
sigma.v.restricted = mean(stan.extract$sigma_v)
load("stan_gp_fits/stan_gp_sf_unconditional.RData")
traceplot(stan.fit)
#Restricted values:
stan.extract = extract(stan.fit)
sigma.u.restricted = mean(stan.extract$sigma_u)
sigma.v.restricted = mean(stan.extract$sigma_v)
H.inv.diag.restricted = apply(stan.extract$H_inv_diag, 2, mean)
alpha.restricted = mean(stan.extract$alpha)
eta.restricted = apply(stan.extract$eta, 2, mean)
cov = normal.cov(alpha.restricted, diag(H.inv.diag.restricted))
L = t(chol(cov))
f = L %*% eta.restricted
epsilon = c(y - f)
log.lik = sum(sapply(epsilon, log.lik.func, sigma.u = sigma.u.restricted, sigma.v = sigma.v.restricted))
log.lik.func = function(epsilon, sigma.u, sigma.v){
sigma.sq = sigma.u^2 + sigma.v^2
sigma = sqrt(sigma.sq)
lambda = sigma.u / sigma.v
return(length(epsilon) * (log(2) - log(sigma)) + dnorm(epsilon / sigma, log = TRUE) + pnorm(epsilon * lambda / sigma, log = TRUE, lower.tail = FALSE))
}
normal.kernel = function(x, alpha, H.inv){
return(alpha^2 * exp(-0.5 * t(x) %*% H.inv %*% x))
}
normal.cov = function(alpha, H.inv){
result = matrix(NA, nrow = N, ncol = N)
for (i in 1:(N - 1)){
result[i, i] = alpha^2
for (j in (i + 1):N){
temp.result = normal.kernel(X[i,] - X[j,], alpha, H.inv)
result[i, j] = temp.result
result[j, i] = temp.result
}
}
result[N, N] = alpha^2
return(result)
}
sigma.u.restricted = mean(stan.extract$sigma_u)
sigma.v.restricted = mean(stan.extract$sigma_v)
H.inv.diag.restricted = apply(stan.extract$H_inv_diag, 2, mean)
alpha.restricted = mean(stan.extract$alpha)
eta.restricted = apply(stan.extract$eta, 2, mean)
cov = normal.cov(alpha.restricted, diag(H.inv.diag.restricted))
L = t(chol(cov))
f = L %*% eta.restricted
epsilon = c(y - f)
log.lik = sum(sapply(epsilon, log.lik.func, sigma.u = sigma.u.restricted, sigma.v = sigma.v.restricted))
log.lik
load("stan_gp_fits/stan_gp_sf_unconditional.RData")
stan.extract = extract(stan.fit)
#Plot
e = y - apply(stan.extract$f, 2, mean)
plot(e ~ y)
#Trace plot:
traceplot(stan.fit)
y.mean
y.mean = mean(y)
y.mean
source('~/git/Iterative_ML/R/stan_sf_data/gp_sf_fit_ml_calc.R', echo=TRUE)
##############################
#Prior evaluation
load("stan_gp_fits/priors.RData")
library(invgamma)
source('~/git/Iterative_ML/R/stan_sf_data/gp_sf_fit_ml_calc.R', echo=TRUE)
source('~/git/Iterative_ML/R/stan_sf_data/par_sf_fit_ml_calc.R', echo=TRUE)
source('~/git/Iterative_ML/R/stan_sf_data/par_translog_sf_fit_ml_calc.R', echo=TRUE)
source('~/git/Iterative_ML/R/stan_sf_data/gp_sf_fit_ml_calc.R', echo=TRUE)
source('~/git/Iterative_ML/R/stan_sf_data/wb_development_data/4_variable_creation.R', echo=TRUE)
nrow(X)
X
df
exp(X)
cbind(countries, exp(X))
load("stan_gp_fits/stan_gp_sf_unconditional.RData")
stan.extract = extract(stan.fit)
#Plot
e = y - apply(stan.extract$f, 2, mean)
plot(e ~ y)
#Trace plot:
traceplot(stan.fit)
#Efficiency estimates
u.mode = function(i){
epsilon = y - stan.extract$f[i,]
sigma.u = stan.extract$sigma_u[i]
sigma.v = stan.extract$sigma_v[i]
sigma.sq = sigma.u^2 + sigma.v^2
raw.epsilon = -epsilon * (sigma.u^2 / sigma.sq)
return(ifelse(raw.epsilon < 0, raw.epsilon, 0))
}
u.mean = function(i){
epsilon = y - stan.extract$f[i,]
sigma.u = stan.extract$sigma_u[i]
sigma.v = stan.extract$sigma_v[i]
sigma.sq = sigma.u^2 + sigma.v^2
sigma = sqrt(sigma.sq)
mu.star = -sigma.u^2 * epsilon / sigma.sq
sigma.sq.star = sigma.u^2 * sigma.v^2 / sigma.sq
sigma.star = sqrt(sigma.sq.star)
lambda = sigma.u / sigma.v
eval.point = epsilon * lambda / sigma
# return(mu.star + sigma.star * dnorm(-mu.star / sigma.star) / (1 - pnorm(-mu.star / sigma.star)))
return(-sigma.star * (dnorm(eval.point) / (1 - pnorm(eval.point)) - eval.point))
}
rm(list = ls())
load("data.RData")
#Priors
alpha_prior_shape = 1
H_inv_diag_prior_shape = 10
H_inv_diag_prior_rate = 1
alpha_prior_rate = 1
sigma_u_prior_rate = 1
sigma_u_prior_shape = 1
sigma_v_prior_shape = 1
sigma_v_prior_rate = 1
y.mean = mean(y)
y = y - y.mean
burn.iter = 9000
sample.iter = 1000
load("stan_gp_fits/stan_gp_sf_unconditional.RData")
stan.extract = extract(stan.fit)
#Plot
e = y - apply(stan.extract$f, 2, mean)
load("stan_gp_fits/stan_gp_sf_unconditional.RData")
setwd("~/git/Iterative_ML/R/stan_sf_data")
rm(list = ls())
load("data.RData")
#Priors
alpha_prior_shape = 1
alpha_prior_rate = 1
H_inv_diag_prior_shape = 10
H_inv_diag_prior_rate = 1
sigma_u_prior_shape = 1
sigma_u_prior_rate = 1
sigma_v_prior_shape = 1
sigma_v_prior_rate = 1
y.mean = mean(y)
y = y - y.mean
burn.iter = 9000
sample.iter = 1000
load("stan_gp_fits/stan_gp_sf_unconditional.RData")
stan.extract = extract(stan.fit)
#Plot
e = y - apply(stan.extract$f, 2, mean)
plot(e ~ y)
#Trace plot:
traceplot(stan.fit)
#Efficiency estimates
u.mode = function(i){
epsilon = y - stan.extract$f[i,]
sigma.u = stan.extract$sigma_u[i]
sigma.v = stan.extract$sigma_v[i]
sigma.sq = sigma.u^2 + sigma.v^2
raw.epsilon = -epsilon * (sigma.u^2 / sigma.sq)
return(ifelse(raw.epsilon < 0, raw.epsilon, 0))
}
u.mean = function(i){
epsilon = y - stan.extract$f[i,]
sigma.u = stan.extract$sigma_u[i]
sigma.v = stan.extract$sigma_v[i]
sigma.sq = sigma.u^2 + sigma.v^2
sigma = sqrt(sigma.sq)
mu.star = -sigma.u^2 * epsilon / sigma.sq
sigma.sq.star = sigma.u^2 * sigma.v^2 / sigma.sq
sigma.star = sqrt(sigma.sq.star)
lambda = sigma.u / sigma.v
eval.point = epsilon * lambda / sigma
# return(mu.star + sigma.star * dnorm(-mu.star / sigma.star) / (1 - pnorm(-mu.star / sigma.star)))
return(-sigma.star * (dnorm(eval.point) / (1 - pnorm(eval.point)) - eval.point))
}
u.posterior = t(sapply(1:sample.iter, u.mean))
cbind(countries, apply(exp(u.posterior), 2, mean))
setwd("~/git/Iterative_ML/R/create_tables")
##############################
#Table 4: Efficiency estimates
load("../stan_sf_data/data.RData")
num.countries = length(countries)
load("../stan_sf_data/stan_par_fits/stan_par_sf_unconditional.RData")
stan.extract = extract(stan.fit)
#Log-linear
u.mean = function(i){
epsilon = y - (stan.extract$beta_const[i] + X %*% stan.extract$beta[i,])
sigma.u = stan.extract$sigma_u[i]
sigma.v = stan.extract$sigma_v[i]
sigma.sq = sigma.u^2 + sigma.v^2
sigma = sqrt(sigma.sq)
mu.star = -sigma.u^2 * epsilon / sigma.sq
sigma.sq.star = sigma.u^2 * sigma.v^2 / sigma.sq
sigma.star = sqrt(sigma.sq.star)
lambda = sigma.u / sigma.v
eval.point = epsilon * lambda / sigma
# return(mu.star + sigma.star * dnorm(-mu.star / sigma.star) / (1 - pnorm(-mu.star / sigma.star)))
return(-sigma.star * (dnorm(eval.point) / (1 - pnorm(eval.point)) - eval.point))
}
u.posterior = t(sapply(1:sample.iter, u.mean))
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
str(stan.fit)
str(stan.extract)
length(stan.extract$beta_const)
stan.fit@sim$iter
stan.fit@sim$iter - stan.fit@sim$warmup
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
table.matrix
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
table.matrix
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
table.matrix
i = 1
epsilon = y - stan.extract$f[i,]
sigma.u = stan.extract$sigma_u[i]
sigma.v = stan.extract$sigma_v[i]
sigma.sq = sigma.u^2 + sigma.v^2
sigma = sqrt(sigma.sq)
mu.star = -sigma.u^2 * epsilon / sigma.sq
sigma.sq.star = sigma.u^2 * sigma.v^2 / sigma.sq
sigma.star = sqrt(sigma.sq.star)
lambda = sigma.u / sigma.v
eval.point = epsilon * lambda / sigma
-sigma.star * (dnorm(eval.point) / (1 - pnorm(eval.point)) - eval.point)
#GP
load("../stan_sf_data/stan_gp_fits/priors.RData")
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
table.matrix
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
table.matrix
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source("../stan_sf_data/par_sf_fit_ml_calc.R")
load("../stan_sf_data/data.RData")
log.lik
X
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
table.matrix
table.matrix[3,] = c("Log-Linear", ncol(X) + 3, round(log.lik, round.digits), round(log.lik + log.prior - log.posterior, round.digits))
table.matrix
choose(ncol(X), 2)
2 * ncol(X) + choose(ncol(X), 2)
X = cbind(X, X^2,
sapply(1:ncol(combos), function(i) X[,combos[1,i]] * X[,combos[2,i]]))
ncol(X)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
getwd()
source("../stan_sf_data/par_translog_sf_fit_ml_calc.R")
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
table.matrix
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
2 * ncol(X) + choose(ncol(X), 2) + 3
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
z = c(-29.208, -68.984, -46.716)
exp(z) / sum(exp(z))
source('~/git/Iterative_ML/R/stan_sf_data/par_translog_sf_fit_ml_calc.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
dnorm(1)
source('~/git/Iterative_ML/R/stan_sf_data/gp_sf_fit_ml_calc.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
source('~/git/Iterative_ML/R/create_tables/create_tables.R', echo=TRUE)
